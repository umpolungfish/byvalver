feat: Implement BYVALVER v4.2 Enhanced x64 Support

Major enhancement adding comprehensive x64 shellcode support through
strategy compatibility layer and 5 new x64-specific strategies.

Problem:
========

Prior to v4.2, x64 shellcode processing had 100% failure rate:
- Only 5 strategies marked BYVAL_ARCH_X64 out of 163+ total
- Strategy filter used strict equality, blocking x86 strategies
- 128+ proven x86 strategies were unavailable for x64 processing

Solution:
=========

Phase 1: x86/x64 Strategy Compatibility Layer
---------------------------------------------
Added is_strategy_arch_compatible() in strategy_registry.c:
- Allows x86 strategies to work on x64 shellcode
- Automatically excludes x86-only instructions (SALC, ARPL, BOUND, BCD)
- Zero code changes required to existing strategies
- Immediate access to 128+ transformation strategies for x64

Phase 2: Extended Register Support Utilities
--------------------------------------------
Added to utils.c, utils.h, and core.c:
- is_64bit_register(): Check if register requires REX.W
- is_extended_register(): Check if register requires REX.B/R/X
- build_rex_prefix(): Construct REX prefix byte
- get_reg_index() extended: Now handles R8-R15 properly

Phase 3: New x64-Specific Strategies
------------------------------------
Five new strategy files targeting x64 instruction patterns:

1. src/movabs_strategies.c (Priority 90)
   - Handles movabs rax, imm64 with null byte elimination
   - XOR key encoding, ADD/SUB construction, byte-by-byte building

2. src/sbb_imm_zero_strategies.c (Priority 86)
   - Transforms SBB AL/AX/EAX, 0 instructions
   - Maintains CF semantics with register operand conversion

3. src/test_large_imm_strategies.c (Priority 85)
   - Handles TEST EAX/RAX, imm32 with null-containing immediates
   - Register operand conversion with XOR key construction

4. src/sse_memory_strategies.c (Priority 88)
   - SSE memory operations (MOVUPS/MOVAPS/MOVDQU/MOVDQA)
   - Address calculation via LEA to temp register

5. src/lea_x64_displacement_strategies.c (Priority 87)
   - Large displacement handling with REX prefix support
   - Displacement decomposition and base register adjustment

Phase 4: Strategy Registration
------------------------------
Added to strategy_registry.c:
- Forward declarations for all new registration functions
- Registration calls in init_strategies() for x64 architecture

Files Modified:
===============

Core Infrastructure:
- src/strategy_registry.c - Compatibility layer + registrations
- src/utils.c - REX prefix utilities
- src/utils.h - Function declarations
- src/core.c - Extended get_reg_index()

New Strategy Files:
- src/movabs_strategies.c (new)
- src/sbb_imm_zero_strategies.c (new)
- src/test_large_imm_strategies.c (new)
- src/sse_memory_strategies.c (new)
- src/lea_x64_displacement_strategies.c (new)

Documentation:
- README.md - v4.2 feature documentation
- docs/DENULL_STRATS.md - New strategy documentation
- assets/docs/BADBYTEELIM_STRATS.md - v4.2 section added

Results:
========

Strategy availability:
- Before: 5 x64-specific strategies
- After: 133+ strategies (5 existing + 128 compatible x86 + 5 new)

Expected improvement:
- x64 shellcode: 0% -> significant success rate
- Total strategies: 163 -> 175+

Technical Notes:
================

The compatibility layer works by checking strategy names for
x86-only instruction patterns. This approach:
1. Requires no changes to existing strategies
2. Maintains full backward compatibility
3. Automatically adapts as new strategies are added
4. Has O(n) overhead only during strategy selection, not execution

