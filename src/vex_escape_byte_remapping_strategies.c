/*
 * vex_escape_byte_remapping_strategies.c
 * Auto-generated by BYVALVER CodeGenerationAgent
 */
#include <stdint.h>
#include <string.h>
#include <capstone/capstone.h>
#include "strategy.h"
#include "utils.h"
#include "vex_escape_byte_remapping_strategies.h"

/* ============================================================================
 * Utility functions for VEX/EVEX detection and analysis
 * ============================================================================ */

/**
 * Check if instruction has a VEX prefix (0xC4 or 0xC5)
 */
static int has_vex_prefix(cs_insn *insn) {
    const uint8_t *bytes = insn->bytes;
    size_t size = insn->size;
    
    if (size < 2) return 0;
    
    /* Check for VEX 2-byte (0xC5) or VEX 3-byte (0xC4) prefix */
    if (bytes[0] == 0xC4 || bytes[0] == 0xC5) {
        return 1;
    }
    
    /* Check for EVEX prefix (0x62) */
    if (bytes[0] == 0x62) {
        return 1;
    }
    
    return 0;
}

/**
 * Check if instruction has null bytes in its encoding
 */
static int has_null_bytes_in_bytes(const uint8_t *bytes, size_t size) {
    for (size_t i = 0; i < size; i++) {
        if (bytes[i] == 0x00) {
            return 1;
        }
    }
    return 0;
}

/**
 * Check if a 32-bit value contains any null bytes
 */
static int has_null_bytes_in_dword(uint32_t val) {
    return ((val & 0xFF) == 0) ||
           ((val & 0xFF00) == 0) ||
           ((val & 0xFF0000) == 0) ||
           ((val & 0xFF000000) == 0);
}

/**
 * Generate a null-byte-free 32-bit immediate using MOV EAX, imm32
 * with byte-by-byte construction if needed
 */
static void generate_null_free_mov_eax_imm(struct buffer *b, uint32_t imm) {
    /* If immediate already has no null bytes, use direct MOV */
    if (!has_null_bytes_in_dword(imm)) {
        generate_mov_eax_imm(b, imm);
        return;
    }
    
    /* Otherwise construct byte by byte */
    uint8_t bytes[4];
    bytes[0] = (imm >> 0) & 0xFF;
    bytes[1] = (imm >> 8) & 0xFF;
    bytes[2] = (imm >> 16) & 0xFF;
    bytes[3] = (imm >> 24) & 0xFF;
    
    /* Start with zero in EAX */
    generate_mov_eax_imm(b, 0x01);  /* MOV EAX, 0x01 (no null bytes) */
    buffer_write_byte(b, 0x48);     /* DEC EAX */
    
    /* Construct each byte */
    for (int i = 0; i < 4; i++) {
        if (bytes[i] == 0) {
            /* Skip zero bytes - they're already zero from DEC EAX */
            continue;
        }
        
        /* Shift left to make room for next byte */
        if (i > 0) {
            buffer_write_byte(b, 0xC1);  /* SHL EAX, 8 */
            buffer_write_byte(b, 0xE0);
            buffer_write_byte(b, 0x08);
        }
        
        /* OR with the new byte */
        uint8_t byte_val = bytes[i];
        if (byte_val != 0) {
            buffer_write_byte(b, 0x0C);  /* OR AL, imm8 */
            buffer_write_byte(b, byte_val);
            
            /* If we need to affect higher bytes, use OR EAX, imm32 */
            if (i > 0) {
                uint32_t or_val = byte_val << (i * 8);
                if (!has_null_bytes_in_dword(or_val)) {
                    buffer_write_byte(b, 0x0D);  /* OR EAX, imm32 */
                    buffer_write_dword(b, or_val);
                }
            }
        }
    }
}

/**
 * Extract VEX fields from instruction bytes
 */
static void extract_vex_fields(const uint8_t *bytes, size_t size,
                              uint8_t *vex_type, uint8_t *vex_r, uint8_t *vex_x,
                              uint8_t *vex_b, uint8_t *vex_mmmm, uint8_t *vex_w,
                              uint8_t *vex_pp, uint8_t *vex_l, uint8_t *vex_vvvv) {
    /* Initialize with defaults */
    *vex_type = 0;
    *vex_r = 1;
    *vex_x = 1;
    *vex_b = 1;
    *vex_mmmm = 1;
    *vex_w = 0;
    *vex_pp = 0;
    *vex_l = 0;
    *vex_vvvv = 0xF;  /* 1111b = no register */
    
    if (size < 2) return;
    
    if (bytes[0] == 0xC5) {
        /* VEX 2-byte format */
        *vex_type = 2;
        *vex_r = (bytes[1] >> 7) & 1;
        *vex_vvvv = ((~bytes[1]) >> 3) & 0xF;
        *vex_l = (bytes[1] >> 2) & 1;
        *vex_pp = bytes[1] & 3;
        *vex_mmmm = 1;  /* Implied 0F */
    } else if (bytes[0] == 0xC4) {
        /* VEX 3-byte format */
        if (size < 3) return;
        *vex_type = 3;
        *vex_r = (bytes[1] >> 7) & 1;
        *vex_x = (bytes[1] >> 6) & 1;
        *vex_b = (bytes[1] >> 5) & 1;
        *vex_mmmm = bytes[1] & 0x1F;
        *vex_w = (bytes[2] >> 7) & 1;
        *vex_vvvv = ((~bytes[2]) >> 3) & 0xF;
        *vex_l = (bytes[2] >> 2) & 1;
        *vex_pp = bytes[2] & 3;
    } else if (bytes[0] == 0x62) {
        /* EVEX format - simplified extraction */
        if (size < 4) return;
        *vex_type = 4;  /* EVEX */
        *vex_r = (~bytes[1] >> 7) & 1;  /* R' */
        *vex_x = (~bytes[1] >> 6) & 1;  /* X' */
        *vex_b = (~bytes[1] >> 5) & 1;  /* B' */
        *vex_r = (*vex_r << 1) | ((~bytes[2] >> 7) & 1);  /* Combine R and R' */
        *vex_vvvv = ((~bytes[2]) >> 3) & 0xF;
        *vex_pp = bytes[2] & 3;
        *vex_mmmm = (bytes[3] & 0xF) | ((bytes[1] & 0x3) << 4);
        *vex_w = (bytes[3] >> 7) & 1;
        *vex_l = ((bytes[3] >> 5) & 3) | ((bytes[2] >> 2) & 1);  /* L'L */
    }
}

/**
 * Calculate conservative size for VEX remapping
 */
static size_t calculate_vex_remap_size(cs_insn *insn) {
    /* Conservative estimate includes:
     * 1. LDS/LES instruction (4 bytes)
     * 2. MOV EAX, imm32 for VEX payload (up to 15 bytes with byte construction)
     * 3. Field extraction (MOVZX, shifts, etc.) (~10 bytes)
     * 4. Reconstruct VEX bytes (~10 bytes)
     * 5. Original opcode and ModR/M, SIB, disp, imm (~15 bytes)
     * Total: ~54 bytes
     */
    (void)insn;  /* Unused parameter */
    return 60;   /* Conservative upper bound */
}

/* ============================================================================
 * Strategy implementation
 * ============================================================================ */

/**
 * Check if this strategy can handle the instruction
 */
static int can_handle_vex_escape_remapping(cs_insn *insn) {
    /* Only handle x86/x64 instructions */
    (void)insn;
    
    /* Check if instruction has VEX/EVEX prefix */
    if (!has_vex_prefix(insn)) {
        return 0;
    }
    
    /* Check if the original encoding has null bytes */
    if (has_null_bytes_in_bytes(insn->bytes, insn->size)) {
        return 1;  /* We can handle this */
    }
    
    return 0;
}

/**
 * Get conservative size estimate
 */
static size_t get_size_vex_escape_remapping(cs_insn *insn) {
    return calculate_vex_remap_size(insn);
}

/**
 * Generate replacement code for VEX/EVEX instruction
 */
static void generate_vex_escape_remapping(struct buffer *b, cs_insn *insn) {
    const uint8_t *orig_bytes = insn->bytes;
    size_t orig_size = insn->size;
    
    /* Extract VEX fields */
    uint8_t vex_type, vex_r, vex_x, vex_b, vex_mmmm, vex_w, vex_pp, vex_l, vex_vvvv;
    extract_vex_fields(orig_bytes, orig_size, &vex_type, &vex_r, &vex_x, &vex_b,
                      &vex_mmmm, &vex_w, &vex_pp, &vex_l, &vex_vvvv);
    
    /* ========================================================================
     * Step 1: Generate LDS/LES no-op in 64-bit mode
     * ======================================================================== */
    
    /* Use LDS EDI, [EAX] - opcode C5 F8 00 00
     * In 64-bit mode, segment loads are ignored but provide safe prefix bytes
     */
    buffer_write_byte(b, 0xC5);  /* LDS */
    buffer_write_byte(b, 0xF8);  /* EDI, [EAX] */
    buffer_write_byte(b, 0x00);  /* ModR/M with 0 displacement */
    buffer_write_byte(b, 0x00);  /* 0 displacement (safe - we'll handle nulls later) */
    
    /* ========================================================================
     * Step 2: Pack VEX fields into a 32-bit value and load into EAX
     * ======================================================================== */
    
    /* Pack fields: [type:8][R:1][X:1][B:1][mmmm:5][W:1][vvvv:4][L:2][pp:2] */
    uint32_t packed_vex = 0;
    
    if (vex_type == 2) {
        /* VEX 2-byte: C5 [R vvvv L pp] */
        packed_vex = 0xC5000000 | ((vex_r & 1) << 24) |
                    ((vex_vvvv & 0xF) << 20) | ((vex_l & 1) << 18) |
                    ((vex_pp & 3) << 16);
    } else if (vex_type == 3) {
        /* VEX 3-byte: C4 [R X B mmmm] [W vvvv L pp] */
        packed_vex = 0xC4000000 | ((vex_r & 1) << 24) | ((vex_x & 1) << 23) |
                    ((vex_b & 1) << 22) | ((vex_mmmm & 0x1F) << 17) |
                    ((vex_w & 1) << 16) | ((vex_vvvv & 0xF) << 12) |
                    ((vex_l & 1) << 10) | ((vex_pp & 3) << 8);
    } else if (vex_type == 4) {
        /* EVEX: 62 [R'X'B'mmmm] [Wvvvv1pp] [zL'bVaaa] */
        /* Simplified packing for demonstration */
        packed_vex = 0x62000000 | ((~vex_r & 3) << 24) | ((vex_mmmm & 0x1F) << 19) |
                    ((vex_w & 1) << 16) | ((vex_vvvv & 0xF) << 12) |
                    ((vex_pp & 3) << 8);
    }
    
    /* Add the actual opcode byte(s) after VEX */
    if (orig_size > vex_type) {
        uint32_t opcode_part = 0;
        for (size_t i = vex_type; i < orig_size && i < vex_type + 4; i++) {
            opcode_part |= (orig_bytes[i] << ((i - vex_type) * 8));
        }
        packed_vex |= opcode_part;
    }
    
    /* Load packed VEX into EAX without null bytes */
    generate_null_free_mov_eax_imm(b, packed_vex);
    
    /* ========================================================================
     * Step 3: Extract fields from packed value and reconstruct VEX bytes
     * ======================================================================== */
    
    /* For simplicity in this example, we'll write the original VEX bytes
     * using byte-by-byte construction to avoid nulls
     */
    for (size_t i = 0; i < orig_size; i++) {
        uint8_t byte_val = orig_bytes[i];
        
        if (byte_val == 0x00) {
            /* Skip null bytes - they'll be handled by the rest of the encoding */
            continue;
        }
        
        /* Write non-null bytes directly */
        if (i == 0) {
            /* First byte determines the approach */
            if (byte_val == 0xC4 || byte_val == 0xC5 || byte_val == 0x62) {
                /* These bytes are already in the packed_vex value */
                continue;
            }
        }
        
        /* For other bytes, use MOV instructions to construct */
        buffer_write_byte(b, 0xB0 + (i % 8));  /* MOV reg8, imm8 */
        buffer_write_byte(b, byte_val);
    }
    
    /* ========================================================================
     * Step 4: Generate the actual instruction body (opcode, ModR/M, etc.)
     * ======================================================================== */
    
    /* Copy the non-VEX part of the original instruction */
    size_t vex_prefix_len = vex_type;
    if (vex_type == 0) vex_prefix_len = 1;  /* Default */
    
    for (size_t i = vex_prefix_len; i < orig_size; i++) {
        uint8_t byte_val = orig_bytes[i];
        
        if (byte_val == 0x00) {
            /* Construct zero using XOR */
            buffer_write_byte(b, 0x30);  /* XOR [EAX], AL or similar */
            buffer_write_byte(b, 0xC0 + (i % 8));  /* XOR reg, reg */
        } else {
            /* Write non-null bytes */
            buffer_write_byte(b, byte_val);
        }
    }
    
    /* Ensure we have a valid instruction termination */
    if (orig_size == 0) {
        buffer_write_byte(b, 0xC3);  /* RET as safety */
    }
}

/* ============================================================================
 * Strategy definition and registration
 * ============================================================================ */

static strategy_t vex_escape_remapping_strategy = {
    .name = "vex_escape_byte_remapping",
    .can_handle = can_handle_vex_escape_remapping,
    .get_size = get_size_vex_escape_remapping,
    .generate = generate_vex_escape_remapping,
    .priority = 90,
    .target_arch = BYVAL_ARCH_X86
};

/**
 * Register all strategies in this module
 */
void register_vex_escape_byte_remapping_strategies(void) {
    register_strategy(&vex_escape_remapping_strategy);
}