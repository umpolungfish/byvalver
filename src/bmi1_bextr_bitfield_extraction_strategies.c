/*
 * bmi1_bextr_bitfield_extraction_strategies.c
 * Auto-generated by BYVALVER CodeGenerationAgent
 * Implementation of BMI1 BEXTR bitfield extraction strategy for bad-byte elimination.
 */

#include "bmi1_bextr_bitfield_extraction_strategies.h"
#include "strategy.h"
#include "utils.h"
#include <capstone/capstone.h>

/**
 * Helper to map Capstone register IDs to hardware register indices (0-7).
 */
static uint8_t get_x86_reg_id(x86_reg reg) {
    switch (reg) {
        case X86_REG_EAX: return 0;
        case X86_REG_ECX: return 1;
        case X86_REG_EDX: return 2;
        case X86_REG_EBX: return 3;
        case X86_REG_ESP: return 4;
        case X86_REG_EBP: return 5;
        case X86_REG_ESI: return 6;
        case X86_REG_EDI: return 7;
        default: return 0xFF;
    }
}

/**
 * Checks if the instruction is an AND with an immediate that represents a contiguous bitmask.
 */
int can_handle_bmi1_bextr(cs_insn *insn) {
    if (insn->id != X86_INS_AND) {
        return 0;
    }

    if (insn->detail->x86.op_count != 2) {
        return 0;
    }

    cs_x86_op *ops = insn->detail->x86.operands;

    // Check for Reg, Imm pattern
    if (ops[0].type != X86_OP_REG || ops[1].type != X86_OP_IMM) {
        return 0;
    }

    // Ensure it's a 32-bit GPR
    if (ops[0].size != 4 || get_x86_reg_id(ops[0].reg) == 0xFF) {
        return 0;
    }

    // Only apply if the instruction contains null bytes
    if (!has_null_bytes(insn)) {
        return 0;
    }

    uint32_t mask = (uint32_t)ops[1].imm;
    if (mask == 0) {
        return 0;
    }

    // Verify if the mask is a contiguous sequence of bits
    int start = -1;
    int len = 0;
    for (int i = 0; i < 32; i++) {
        if (mask & (1U << i)) {
            if (start == -1) {
                start = i;
            } else if (len > 0 && !(mask & (1U << (i - 1)))) {
                // Found a gap in the bits
                return 0;
            }
            len++;
        }
    }

    // Double-check: (mask) should be equal to a generated contiguous mask
    uint32_t expected;
    if (len == 32) {
        expected = 0xFFFFFFFF;
    } else {
        expected = ((1U << len) - 1) << start;
    }

    if (mask != expected) {
        return 0;
    }

    return 1;
}

/**
 * Calculates a conservative upper bound for the replacement size.
 * Replacement structure:
 * 1. MOV scratch, ~(control) [5 bytes]
 * 2. NOT scratch             [2 bytes]
 * 3. BEXTR dest, dest, scratch [5 bytes]
 * Total: 12 bytes. Returning 20 to be safe.
 */
size_t get_size_bmi1_bextr(cs_insn *insn) {
    (void)insn;
    return 20;
}

/**
 * Generates the replacement BMI1 BEXTR sequence.
 * Uses a scratch register to construct the control value without null bytes.
 */
void generate_bmi1_bextr(struct buffer *b, cs_insn *insn) {
    cs_x86_op *ops = insn->detail->x86.operands;
    uint32_t mask = (uint32_t)ops[1].imm;

    // Identify start and length for BEXTR control
    uint8_t start = 0;
    uint8_t len = 0;
    for (int i = 0; i < 32; i++) {
        if (mask & (1U << i)) {
            start = (uint8_t)i;
            break;
        }
    }
    for (int i = start; i < 32; i++) {
        if (mask & (1U << i)) {
            len++;
        } else {
            break;
        }
    }

    // BEXTR Control Value: bits 0-7 = start index, bits 8-15 = length
    uint32_t control = (uint32_t)((len << 8) | start);

    // Pick a scratch register (ECX, EDX, or EAX) that isn't the destination
    uint8_t dest_id = get_x86_reg_id(ops[0].reg);
    uint8_t scratch_id;
    if (dest_id == 1) { // If dest is ECX
        scratch_id = 2; // Use EDX
    } else if (dest_id == 2) { // If dest is EDX
        scratch_id = 0; // Use EAX
    } else {
        scratch_id = 1; // Default to ECX
    }

    /* 
     * Load control value into scratch register without nulls.
     * We use: MOV scratch, ~(control); NOT scratch.
     * Since control <= 0x201F, ~(control) will never have null bytes (0xFF ^ 0x00 = 0xFF, 0xFF ^ 0x20 = 0xDF).
     */
    uint32_t inverted_control = control ^ 0xFFFFFFFF;
    buffer_write_byte(b, 0xB8 + scratch_id); // MOV r32, imm32
    buffer_write_dword(b, inverted_control);

    // NOT scratch (F7 /2)
    buffer_write_byte(b, 0xF7);
    buffer_write_byte(b, 0xD0 + scratch_id);

    /*
     * Generate BEXTR dest, dest, scratch
     * Opcode: VEX.LZ.0F38.W0 F7 /r
     * VEX Map 2 (0F 38)
     */
    
    // VEX Byte 0
    buffer_write_byte(b, 0xC4);

    // VEX Byte 1: R=1, X=1, B=1, m-mmmm=00010 (Map 2) -> 1110 0010 = 0xE2
    buffer_write_byte(b, 0xE2);

    // VEX Byte 2: W=0, ~vvvv=scratch, L=0, pp=01 (66 prefix)
    uint8_t scratch_inv = (~scratch_id) & 0x0F;
    uint8_t vex_b2 = (uint8_t)((scratch_inv << 3) | 0x01);
    buffer_write_byte(b, vex_b2);

    // Opcode
    buffer_write_byte(b, 0xF7);

    // ModRM: reg=dest, rm=dest, mod=11 (reg-reg)
    uint8_t modrm = (uint8_t)(0xC0 | (dest_id << 3) | dest_id);
    buffer_write_byte(b, modrm);
}

strategy_t bmi1_bextr_bitfield_extraction_strategy = {
    .name = "bmi1_bextr_bitfield_extraction",
    .can_handle = can_handle_bmi1_bextr,
    .get_size = get_size_bmi1_bextr,
    .generate = generate_bmi1_bextr,
    .priority = 82,
    .target_arch = BYVAL_ARCH_X86
};

void register_bmi1_bextr_bitfield_extraction_strategies(void) {
    register_strategy(&bmi1_bextr_bitfield_extraction_strategy);
}