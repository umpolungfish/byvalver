/*
 * bmi2_flags_preserving_shift_transformation_strategies.c
 * Auto-generated by BYVALVER CodeGenerationAgent
 */
#include <stdint.h>
#include <stddef.h>
#include <capstone/capstone.h>
#include "strategy.h"
#include "utils.h"

/**
 * Maps a Capstone x86 register to its hardware index (0-7).
 * Handles both 32-bit and 8-bit variants (e.g., EAX, CL).
 */
static uint8_t get_x86_reg_index_bmi2(x86_reg r) {
    switch (r) {
        case X86_REG_EAX: case X86_REG_AX: case X86_REG_AL: case X86_REG_AH: return 0;
        case X86_REG_ECX: case X86_REG_CX: case X86_REG_CL: case X86_REG_CH: return 1;
        case X86_REG_EDX: case X86_REG_DX: case X86_REG_DL: case X86_REG_DH: return 2;
        case X86_REG_EBX: case X86_REG_BX: case X86_REG_BL: case X86_REG_BH: return 3;
        case X86_REG_ESP: case X86_REG_SP:                                  return 4;
        case X86_REG_EBP: case X86_REG_BP:                                  return 5;
        case X86_REG_ESI: case X86_REG_SI:                                  return 6;
        case X86_REG_EDI: case X86_REG_DI:                                  return 7;
        default: return 0xFF;
    }
}

/**
 * Checks if the BMI2 Shift strategy can handle the instruction.
 * Targets: SHL, SHR, SAR on 32-bit registers.
 */
static int can_handle_bmi2_shift(cs_insn *insn) {
    // Only handle SHL, SHR, SAR
    if (insn->id != X86_INS_SHL && insn->id != X86_INS_SHR && insn->id != X86_INS_SAR) {
        return 0;
    }

    // Must have 2 operands (dest, count)
    if (insn->detail->x86.op_count != 2) {
        return 0;
    }

    // Destination must be a 32-bit GPR
    if (insn->detail->x86.operands[0].type != X86_OP_REG || 
        insn->detail->x86.operands[0].size != 4) {
        return 0;
    }

    // Only apply if the original instruction contains null bytes
    if (!has_null_bytes(insn)) {
        return 0;
    }

    // Count can be register (typically CL) or Immediate
    if (insn->detail->x86.operands[1].type == X86_OP_REG) {
        return 1;
    } else if (insn->detail->x86.operands[1].type == X86_OP_IMM) {
        int64_t imm = insn->detail->x86.operands[1].imm;
        // Count 0 is a NOP, counts > 31 are masked on x86; only handle 1-31 to be safe
        // Also ensure the immediate byte itself is not 0x00
        if (imm > 0 && imm <= 31) {
            return 1;
        }
    }

    return 0;
}

/**
 * Returns conservative size estimate for the replacement.
 * Max: PUSH ECX (1) + PUSH imm (2) + POP ECX (1) + BMI2 (5) + POP ECX (1) = 10 bytes.
 */
static size_t get_size_bmi2_shift(cs_insn *insn) {
    (void)insn;
    return 15;
}

/**
 * Generates BMI2-equivalent sequence for shifts.
 * Preserves flags (BMI2 shifts don't modify EFLAGS) and avoids bad bytes.
 */
static void generate_bmi2_shift(struct buffer *b, cs_insn *insn) {
    uint8_t dest_idx = get_x86_reg_index_bmi2(insn->detail->x86.operands[0].reg);
    uint8_t count_idx = 0;
    uint8_t pp = 0; // VEX.pp field
    int needs_scratch = 0;

    // Map legacy instruction to BMI2 VEX.pp prefix
    switch (insn->id) {
        case X86_INS_SHL: pp = 1; break; // 66h prefix mapping
        case X86_INS_SAR: pp = 2; break; // F3h prefix mapping
        case X86_INS_SHR: pp = 3; break; // F2h prefix mapping
        default: return; 
    }

    // Handle count operand
    if (insn->detail->x86.operands[1].type == X86_OP_IMM) {
        needs_scratch = 1;
        uint8_t imm = (uint8_t)(insn->detail->x86.operands[1].imm & 0xFF);
        
        // Save ECX, load immediate, use ECX (index 1) as count register
        buffer_write_byte(b, 0x51); // PUSH ECX
        buffer_write_byte(b, 0x6A); // PUSH imm8
        buffer_write_byte(b, imm);
        buffer_write_byte(b, 0x59); // POP ECX
        count_idx = 1;
    } else {
        count_idx = get_x86_reg_index_bmi2(insn->detail->x86.operands[1].reg);
    }

    /*
     * Emit BMI2 instruction: VEX.3Byte 0xC4
     * Byte 1: R X B m-mmmm (R=1, X=1, B=1, map=00010 for 0F 38)
     * Byte 2: W vvvv L pp (W=0 for 32-bit, vvvv=~count_idx, L=0, pp=prefix)
     */
    uint8_t vvvv = (~count_idx) & 0x0F;
    uint8_t vex_b2 = (uint8_t)((vvvv << 3) | pp); // W=0, L=0 bits are 0

    buffer_write_byte(b, 0xC4);   // VEX 3-byte prefix start
    buffer_write_byte(b, 0xE2);   // R=1, X=1, B=1, map=2
    buffer_write_byte(b, vex_b2); // W, vvvv, L, pp
    buffer_write_byte(b, 0xF7);   // Opcode for SHLX/SHRX/SARX

    /*
     * ModR/M byte: Mod=11 (Reg-to-Reg), Reg=dest, RM=source
     * For legacy shifts, the source operand is the same as the destination.
     */
    uint8_t modrm = (uint8_t)(0xC0 | (dest_idx << 3) | dest_idx);
    buffer_write_byte(b, modrm);

    // Cleanup scratch register if used
    if (needs_scratch) {
        buffer_write_byte(b, 0x59); // POP ECX
    }
}

/**
 * Strategy definition for the BMI2 Shift Transformation.
 */
strategy_t bmi2_shift_strategy = {
    .name = "bmi2_flags_preserving_shift_transformation",
    .can_handle = can_handle_bmi2_shift,
    .get_size = get_size_bmi2_shift,
    .generate = generate_bmi2_shift,
    .priority = 88,
    .target_arch = BYVAL_ARCH_X86
};

/**
 * Registration function called by the core engine.
 */
void register_bmi2_flags_preserving_shift_transformation_strategies(void) {
    register_strategy(&bmi2_shift_strategy);
}