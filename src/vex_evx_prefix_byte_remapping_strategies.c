/*
 * vex_evx_prefix_byte_remapping_strategies.c
 * Auto-generated by BYVALVER CodeGenerationAgent
 */
#include <stdint.h>
#include <string.h>
#include <capstone/capstone.h>
#include "strategy.h"
#include "utils.h"
#include "vex_evx_prefix_byte_remapping_strategies.h"

/* ============================================================================
 * Utility functions for VEX/EVEX instruction analysis
 * ============================================================================ */

/* Check if instruction has a VEX prefix (C4 or C5) */
static int has_vex_prefix(cs_insn *insn) {
    if (insn->size < 2) return 0;
    const uint8_t *bytes = insn->bytes;
    return (bytes[0] == 0xC4 || bytes[0] == 0xC5);
}

/* Check if instruction has an EVEX prefix (0x62) */
static int has_evex_prefix(cs_insn *insn) {
    if (insn->size < 1) return 0;
    return (insn->bytes[0] == 0x62);
}

/* Extract VEX fields from instruction bytes */
static void extract_vex_fields(cs_insn *insn, 
                               uint8_t *vex_type,      /* 2-byte (C5) or 3-byte (C4) */
                               uint8_t *vex_r,         /* R bit (inverted) */
                               uint8_t *vex_x,         /* X bit (inverted) */
                               uint8_t *vex_b,         /* B bit (inverted) */
                               uint8_t *vex_mmmmm,     /* map select */
                               uint8_t *vex_w,         /* W bit */
                               uint8_t *vex_pp,        /* prefix field */
                               uint8_t *vex_vvvv) {    /* VEX.vvvv field */
    const uint8_t *bytes = insn->bytes;
    
    if (bytes[0] == 0xC5) { /* 2-byte VEX */
        *vex_type = 2;
        uint8_t byte1 = bytes[1];
        *vex_r = (byte1 >> 7) & 1;
        *vex_x = 1; /* Not present in 2-byte form, default to 1 */
        *vex_b = 1; /* Not present in 2-byte form, default to 1 */
        *vex_vvvv = (~byte1 >> 3) & 0x0F;
        *vex_w = 0; /* Not present in 2-byte form */
        *vex_pp = byte1 & 0x03;
        *vex_mmmmm = 1; /* Implied map 1 for 2-byte VEX */
    } else if (bytes[0] == 0xC4) { /* 3-byte VEX */
        *vex_type = 3;
        uint8_t byte1 = bytes[1];
        uint8_t byte2 = bytes[2];
        *vex_r = (byte1 >> 7) & 1;
        *vex_x = (byte1 >> 6) & 1;
        *vex_b = (byte1 >> 5) & 1;
        *vex_mmmmm = byte1 & 0x1F;
        *vex_w = (byte2 >> 7) & 1;
        *vex_vvvv = (~byte2 >> 3) & 0x0F;
        *vex_pp = byte2 & 0x03;
    } else {
        *vex_type = 0;
    }
}

/* Extract EVEX fields from instruction bytes */
static void extract_evex_fields(cs_insn *insn,
                                uint8_t *evex_r,        /* R' + R bits */
                                uint8_t *evex_x,        /* X bit */
                                uint8_t *evex_b,        /* B bit */
                                uint8_t *evex_r2,       /* R' bit */
                                uint8_t *evex_mm,       /* mm field */
                                uint8_t *evex_w,        /* W bit */
                                uint8_t *evex_vvvv,     /* vvvv field */
                                uint8_t *evex_pp,       /* pp field */
                                uint8_t *evex_z,        /* z bit */
                                uint8_t *evex_bc,       /* broadcast/rc/sae */
                                uint8_t *evex_aaa) {    /* aaa (embedded opmask) */
    const uint8_t *bytes = insn->bytes;
    
    if (bytes[0] != 0x62) return;
    
    uint8_t byte1 = bytes[1];
    uint8_t byte2 = bytes[2];
    uint8_t byte3 = bytes[3];
    
    *evex_r = (byte1 >> 7) & 1;
    *evex_x = (byte1 >> 6) & 1;
    *evex_b = (byte1 >> 5) & 1;
    *evex_r2 = (byte1 >> 4) & 1;
    *evex_mm = byte1 & 0x03;
    
    *evex_w = (byte2 >> 7) & 1;
    *evex_vvvv = (~byte2 >> 3) & 0x0F;
    *evex_pp = byte2 & 0x03;
    
    *evex_z = (byte3 >> 7) & 1;
    *evex_bc = (byte3 >> 5) & 0x03;  /* LL field */
    *evex_aaa = byte3 & 0x07;
}

/* Check if a byte is bad (contains 0x00) */
static int is_bad_byte(uint8_t b) {
    return b == 0x00;
}

/* Check if any byte in the instruction is bad */
static int has_bad_bytes_in_instruction(cs_insn *insn) {
    for (size_t i = 0; i < insn->size; i++) {
        if (is_bad_byte(insn->bytes[i])) {
            return 1;
        }
    }
    return 0;
}

/* Check if we can toggle R/X/B bits to avoid bad bytes */
static int can_toggle_vex_bits(cs_insn *insn) {
    (void)insn; /* Parameter used in logic below */
    
    /* For VEX instructions, we can toggle R/X/B bits */
    if (has_vex_prefix(insn)) {
        return 1;
    }
    
    /* For EVEX instructions, we can toggle R/X/B/R' bits */
    if (has_evex_prefix(insn)) {
        return 1;
    }
    
    return 0;
}

/* Check if we can switch between 2-byte and 3-byte VEX forms */
static int can_switch_vex_form(cs_insn *insn) {
    if (!has_vex_prefix(insn)) return 0;
    
    const uint8_t *bytes = insn->bytes;
    
    /* Only instructions with map 0 or 1 can use 2-byte VEX */
    if (bytes[0] == 0xC4) { /* 3-byte VEX */
        uint8_t mmmmm = bytes[1] & 0x1F;
        /* 2-byte VEX only supports map 1 */
        return (mmmmm == 1);
    } else if (bytes[0] == 0xC5) { /* 2-byte VEX */
        /* Can always convert to 3-byte VEX with map 1 */
        return 1;
    }
    
    return 0;
}

/* ============================================================================
 * Strategy 1: VEX Prefix Byte Remapping
 * ============================================================================ */

static int can_handle_vex_remapping(cs_insn *insn) {
    (void)insn;
    
    /* Only handle VEX-prefixed instructions */
    if (!has_vex_prefix(insn)) {
        return 0;
    }
    
    /* Only handle if there are bad bytes to avoid */
    if (!has_bad_bytes_in_instruction(insn)) {
        return 0;
    }
    
    /* Check if we have any remapping options */
    if (!can_toggle_vex_bits(insn) && !can_switch_vex_form(insn)) {
        return 0;
    }
    
    return 1;
}

static size_t get_size_vex_remapping(cs_insn *insn) {
    (void)insn;
    
    /* Conservative estimate: 
     * - Original VEX instruction size (up to 8 bytes)
     * - Plus potential extra bytes for register adjustments
     * - Maximum: 12 bytes
     */
    return 12;
}

static void generate_vex_remapping(struct buffer *buf, cs_insn *insn) {
    const uint8_t *orig_bytes = insn->bytes;
    size_t orig_size = insn->size;
    
    /* Extract original VEX fields */
    uint8_t vex_type, vex_r, vex_x, vex_b, vex_mmmmm, vex_w, vex_pp, vex_vvvv;
    extract_vex_fields(insn, &vex_type, &vex_r, &vex_x, &vex_b, 
                      &vex_mmmmm, &vex_w, &vex_pp, &vex_vvvv);
    
    /* Check which bytes are bad */
    int bad_prefix = is_bad_byte(orig_bytes[0]);
    int bad_second_byte = (orig_size > 1) && is_bad_byte(orig_bytes[1]);
    
    /* Try toggling R/X/B bits first */
    uint8_t new_r = vex_r;
    uint8_t new_x = vex_x;
    uint8_t new_b = vex_b;
    
    if (bad_second_byte && vex_type == 3) {
        /* Toggle bits in byte1 to avoid bad byte */
        new_r = !vex_r;
        new_x = !vex_x;
        new_b = !vex_b;
    }
    
    /* Try switching between 2-byte and 3-byte forms */
    int use_2byte = 0;
    int use_3byte = 0;
    
    if (bad_prefix) {
        /* If C4/C5 is bad, switch form */
        if (orig_bytes[0] == 0xC4) {
            use_2byte = 1; /* Switch to 2-byte VEX (C5) */
        } else if (orig_bytes[0] == 0xC5) {
            use_3byte = 1; /* Switch to 3-byte VEX (C4) */
        }
    }
    
    /* Generate new instruction */
    if (use_2byte && vex_mmmmm == 1) {
        /* Convert to 2-byte VEX (C5) */
        uint8_t byte1 = (new_r << 7) | ((~vex_vvvv & 0x0F) << 3) | vex_pp;
        if (!is_bad_byte(0xC5) && !is_bad_byte(byte1)) {
            buffer_write_byte(buf, 0xC5);
            buffer_write_byte(buf, byte1);
            /* Copy remaining bytes (opcode, ModR/M, etc.) */
            for (size_t i = 3; i < orig_size; i++) {
                buffer_write_byte(buf, orig_bytes[i]);
            }
            return;
        }
    } else if (use_3byte || vex_type == 2) {
        /* Convert to 3-byte VEX (C4) or keep 3-byte with toggled bits */
        uint8_t byte1 = (new_r << 7) | (new_x << 6) | (new_b << 5) | vex_mmmmm;
        uint8_t byte2 = (vex_w << 7) | ((~vex_vvvv & 0x0F) << 3) | vex_pp;
        
        if (!is_bad_byte(0xC4) && !is_bad_byte(byte1) && !is_bad_byte(byte2)) {
            buffer_write_byte(buf, 0xC4);
            buffer_write_byte(buf, byte1);
            buffer_write_byte(buf, byte2);
            /* Copy remaining bytes */
            for (size_t i = vex_type; i < orig_size; i++) {
                buffer_write_byte(buf, orig_bytes[i]);
            }
            return;
        }
    }
    
    /* Fallback: toggle bits in 3-byte VEX */
    if (vex_type == 3) {
        uint8_t byte1 = (new_r << 7) | (new_x << 6) | (new_b << 5) | vex_mmmmm;
        uint8_t byte2 = (vex_w << 7) | ((~vex_vvvv & 0x0F) << 3) | vex_pp;
        
        buffer_write_byte(buf, 0xC4);
        buffer_write_byte(buf, byte1);
        buffer_write_byte(buf, byte2);
        for (size_t i = 3; i < orig_size; i++) {
            buffer_write_byte(buf, orig_bytes[i]);
        }
        return;
    }
    
    /* Last resort: copy original (shouldn't reach here if can_handle returned true) */
    for (size_t i = 0; i < orig_size; i++) {
        buffer_write_byte(buf, orig_bytes[i]);
    }
}

/* Strategy structure for VEX remapping */
static strategy_t vex_remapping_strategy = {
    .name = "vex_prefix_byte_remapping",
    .can_handle = can_handle_vex_remapping,
    .get_size = get_size_vex_remapping,
    .generate = generate_vex_remapping,
    .priority = 85,
    .target_arch = BYVAL_ARCH_X86
};

/* ============================================================================
 * Strategy 2: EVEX Prefix Byte Remapping
 * ============================================================================ */

static int can_handle_evex_remapping(cs_insn *insn) {
    (void)insn;
    
    /* Only handle EVEX-prefixed instructions */
    if (!has_evex_prefix(insn)) {
        return 0;
    }
    
    /* Only handle if there are bad bytes to avoid */
    if (!has_bad_bytes_in_instruction(insn)) {
        return 0;
    }
    
    return 1;
}

static size_t get_size_evex_remapping(cs_insn *insn) {
    (void)insn;
    
    /* Conservative estimate: 
     * - EVEX instructions can be up to 8 bytes
     * - Plus potential extra bytes for register adjustments
     * - Maximum: 12 bytes
     */
    return 12;
}

static void generate_evex_remapping(struct buffer *buf, cs_insn *insn) {
    const uint8_t *orig_bytes = insn->bytes;
    size_t orig_size = insn->size;
    
    /* Extract EVEX fields */
    uint8_t evex_r = 0, evex_x = 0, evex_b = 0, evex_r2 = 0, evex_mm = 0, evex_w = 0, evex_vvvv = 0;
    uint8_t evex_pp = 0, evex_z = 0, evex_bc = 0, evex_aaa = 0;
    
    extract_evex_fields(insn, &evex_r, &evex_x, &evex_b, &evex_r2, &evex_mm,
                       &evex_w, &evex_vvvv, &evex_pp, &evex_z, &evex_bc, &evex_aaa);
    
    /* Check which bytes are bad */
    int bad_prefix = is_bad_byte(orig_bytes[0]);
    int bad_byte1 = (orig_size > 1) && is_bad_byte(orig_bytes[1]);
    
    /* Try toggling R/X/B/R' bits to avoid bad bytes */
    uint8_t new_r = evex_r;
    uint8_t new_x = evex_x;
    uint8_t new_b = evex_b;
    uint8_t new_r2 = evex_r2;
    
    if (bad_byte1) {
        /* Toggle bits in byte1 */
        new_r = !evex_r;
        new_x = !evex_x;
        new_b = !evex_b;
        new_r2 = !evex_r2;
    }
    
    /* Reconstruct EVEX bytes */
    uint8_t byte1 = (new_r << 7) | (new_x << 6) | (new_b << 5) | 
                   (new_r2 << 4) | evex_mm;
    uint8_t byte2 = (evex_w << 7) | ((~evex_vvvv & 0x0F) << 3) | evex_pp;
    uint8_t byte3 = (evex_z << 7) | (evex_bc << 5) | evex_aaa;
    
    /* Check if new bytes are bad-byte free */
    if (!bad_prefix && !is_bad_byte(byte1) && !is_bad_byte(byte2) && !is_bad_byte(byte3)) {
        buffer_write_byte(buf, 0x62); /* EVEX prefix */
        buffer_write_byte(buf, byte1);
        buffer_write_byte(buf, byte2);
        buffer_write_byte(buf, byte3);
        
        /* Copy remaining bytes */
        for (size_t i = 4; i < orig_size; i++) {
            buffer_write_byte(buf, orig_bytes[i]);
        }
        return;
    }
    
    /* If we can't avoid all bad bytes, try partial fixes */
    if (bad_prefix) {
        /* Can't fix bad 0x62 prefix - EVEX always starts with 0x62 */
        /* Fall through to copy original */
    } else {
        /* Use the best combination we found */
        buffer_write_byte(buf, 0x62);
        buffer_write_byte(buf, byte1);
        buffer_write_byte(buf, byte2);
        buffer_write_byte(buf, byte3);
        for (size_t i = 4; i < orig_size; i++) {
            buffer_write_byte(buf, orig_bytes[i]);
        }
        return;
    }
    
    /* Last resort: copy original */
    for (size_t i = 0; i < orig_size; i++) {
        buffer_write_byte(buf, orig_bytes[i]);
    }
}

/* Strategy structure for EVEX remapping */
static strategy_t evex_remapping_strategy = {
    .name = "evex_prefix_byte_remapping",
    .can_handle = can_handle_evex_remapping,
    .get_size = get_size_evex_remapping,
    .generate = generate_evex_remapping,
    .priority = 85,
    .target_arch = BYVAL_ARCH_X86
};

/* ============================================================================
 * Registration Function
 * ============================================================================ */

void register_vex_evx_prefix_byte_remapping_strategies(void) {
    register_strategy(&vex_remapping_strategy);
    register_strategy(&evex_remapping_strategy);
}