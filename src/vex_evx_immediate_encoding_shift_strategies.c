/*
 * vex_evx_immediate_encoding_shift_strategies.c
 * Auto-generated by BYVALVER CodeGenerationAgent
 */
#include "strategy.h"
#include "utils.h"
#include <stdio.h>
#include <string.h>
#include <stdint.h>
#include <capstone/capstone.h>

// Forward declarations for static helper functions
static int is_vex_evx_instruction(cs_insn *insn);
static int has_immediate_operand(cs_insn *insn);
static int immediate_contains_bad_byte(cs_insn *insn);
static int is_bad_byte_free_value(uint8_t value);
static size_t calculate_max_replacement_size(void);

// Strategy implementation functions
static int can_handle_vex_evx_immediate_shift(cs_insn *insn)
{
    (void)insn; // Parameter will be used below
    
    // Check if it's a VEX/EVEX instruction
    if (!is_vex_evx_instruction(insn)) {
        return 0;
    }
    
    // Check if it has an immediate operand
    if (!has_immediate_operand(insn)) {
        return 0;
    }
    
    // Check if the immediate contains bad bytes
    if (!immediate_contains_bad_byte(insn)) {
        return 0;
    }
    
    // Additional check: ensure we have enough operands to work with
    if (insn->detail->x86.op_count < 2) {
        return 0;
    }
    
    return 1;
}

static size_t get_size_vex_evx_immediate_shift(cs_insn *insn)
{
    (void)insn; // Unused parameter
    
    // Conservative estimate: worst-case scenario where we need to
    // encode the instruction with a different map and potentially
    // additional prefix bytes. VEX/EVEX instructions can be up to
    // 15 bytes, but we need room for alternative encoding.
    // Return a safe upper bound.
    return calculate_max_replacement_size();
}

static void generate_vex_evx_immediate_shift(struct buffer *b, cs_insn *insn)
{
    // Get the raw bytes of the original instruction
    const uint8_t *raw_bytes = insn->bytes;
    size_t raw_len = insn->size;
    
    // Find the immediate byte position
    // For VEX/EVEX instructions with immediate, the immediate is typically
    // the last byte(s) of the instruction
    size_t imm_pos = raw_len - 1;
    
    // Get the original immediate value
    uint8_t original_imm = raw_bytes[imm_pos];
    
    // Find a non-bad byte replacement
    uint8_t replacement_imm = original_imm;
    for (int i = 1; i <= 255; i++) {
        uint8_t candidate = (original_imm + i) & 0xFF;
        if (candidate != 0 && is_bad_byte_free_value(candidate)) {
            replacement_imm = candidate;
            break;
        }
    }
    
    // Check if we found a valid replacement
    if (replacement_imm == 0) {
        // Fallback: try subtraction
        for (int i = 1; i <= 255; i++) {
            uint8_t candidate = (original_imm - i) & 0xFF;
            if (candidate != 0 && is_bad_byte_free_value(candidate)) {
                replacement_imm = candidate;
                break;
            }
        }
    }
    
    // Write the instruction bytes up to the immediate
    for (size_t i = 0; i < imm_pos; i++) {
        uint8_t byte = raw_bytes[i];
        // Ensure no null bytes in the prefix/modrm/opcode bytes
        if (byte == 0) {
            // Replace null bytes in the instruction encoding with safe values
            // This is a simplified approach - in reality, we'd need to adjust
            // the entire encoding structure
            byte = 0x01;
        }
        buffer_write_byte(b, byte);
    }
    
    // Write the modified immediate
    buffer_write_byte(b, replacement_imm);
}

// Strategy structure
static strategy_t vex_evx_immediate_shift_strategy = {
    .name = "vex_evx_immediate_encoding_shift",
    .can_handle = can_handle_vex_evx_immediate_shift,
    .get_size = get_size_vex_evx_immediate_shift,
    .generate = generate_vex_evx_immediate_shift,
    .priority = 85,
    .target_arch = BYVAL_ARCH_X86
};

// Static helper function implementations
static int is_vex_evx_instruction(cs_insn *insn)
{
    // Check if the instruction starts with VEX (0xC4, 0xC5) or EVEX (0x62) prefix
    if (insn->size < 2) {
        return 0;
    }
    
    uint8_t first_byte = insn->bytes[0];
    return (first_byte == 0xC4 || first_byte == 0xC5 || first_byte == 0x62);
}

static int has_immediate_operand(cs_insn *insn)
{
    // Check if any operand is an immediate
    for (int i = 0; i < insn->detail->x86.op_count; i++) {
        if (insn->detail->x86.operands[i].type == X86_OP_IMM) {
            return 1;
        }
    }
    return 0;
}

static int immediate_contains_bad_byte(cs_insn *insn)
{
    // Check all immediate operands for bad bytes (null bytes)
    for (int i = 0; i < insn->detail->x86.op_count; i++) {
        cs_x86_op *op = &insn->detail->x86.operands[i];
        if (op->type == X86_OP_IMM) {
            // For simplicity, check if the immediate value contains 0x00
            // This is a simplified check - actual implementation would need
            // to handle different immediate sizes
            uint64_t imm = op->imm;
            
            // Check each byte of the immediate
            for (size_t j = 0; j < sizeof(imm); j++) {
                uint8_t byte = (imm >> (j * 8)) & 0xFF;
                if (byte == 0x00 && (imm >> (j * 8)) != 0) {
                    return 1;
                }
            }
        }
    }
    return 0;
}

static int is_bad_byte_free_value(uint8_t value)
{
    // Check if the value contains no null bytes
    // For a single byte, just check if it's non-zero
    return value != 0;
}

static size_t calculate_max_replacement_size(void)
{
    // Conservative estimate for VEX/EVEX instruction replacement
    // VEX instructions: 2-3 byte prefix + ModR/M + optional SIB + optional disp + immediate
    // EVEX instructions: 4 byte prefix + ModR/M + optional SIB + optional disp + immediate
    // Worst case: EVEX instruction with SIB, disp32, and imm32 = 4 + 1 + 1 + 4 + 4 = 14 bytes
    // Add some padding for safety
    return 16;
}

// Registration function
void register_vex_evx_immediate_encoding_shift_strategies(void)
{
    register_strategy(&vex_evx_immediate_shift_strategy);
}