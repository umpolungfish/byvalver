/*
 * vex_evex_prefix_remapping_for_avx_immediate_strategies.c
 * Auto-generated by BYVALVER CodeGenerationAgent
 */
#include <stdint.h>
#include <string.h>
#include <capstone/capstone.h>
#include "strategy.h"
#include "utils.h"

/* ============================================================================
 * Utility functions for VEX/EVEX analysis
 * ============================================================================ */

/**
 * Check if instruction has a VEX prefix (C4 or C5).
 */
static int has_vex_prefix(cs_insn *insn) {
    const uint8_t *bytes = insn->bytes;
    size_t size = insn->size;
    
    if (size < 2) return 0;
    
    // VEX2 prefix: C5
    if (bytes[0] == 0xC5) return 1;
    
    // VEX3 prefix: C4
    if (bytes[0] == 0xC4) return 1;
    
    return 0;
}

/**
 * Check if instruction has an EVEX prefix (62).
 */
static int has_evex_prefix(cs_insn *insn) {
    const uint8_t *bytes = insn->bytes;
    size_t size = insn->size;
    
    if (size < 1) return 0;
    
    return (bytes[0] == 0x62);
}

/**
 * Check if instruction is VEX/EVEX prefixed.
 */
static int is_vex_evex_instruction(cs_insn *insn) {
    return has_vex_prefix(insn) || has_evex_prefix(insn);
}

/**
 * Check if instruction has an immediate operand.
 */
static int has_immediate_operand(cs_insn *insn) {
    for (int i = 0; i < insn->detail->x86.op_count; i++) {
        if (insn->detail->x86.operands[i].type == X86_OP_IMM) {
            return 1;
        }
    }
    return 0;
}

/**
 * Check if any byte in the instruction is 0x00.
 */
static int has_null_bytes_in_instruction(cs_insn *insn) {
    const uint8_t *bytes = insn->bytes;
    for (size_t i = 0; i < insn->size; i++) {
        if (bytes[i] == 0x00) {
            return 1;
        }
    }
    return 0;
}

/**
 * Check if immediate field contains null bytes.
 * For VEX/EVEX instructions, the immediate is typically at the end.
 */
static int has_null_bytes_in_immediate(cs_insn *insn) {
    const uint8_t *bytes = insn->bytes;
    size_t size = insn->size;
    
    // Find immediate operand
    for (int i = 0; i < insn->detail->x86.op_count; i++) {
        if (insn->detail->x86.operands[i].type == X86_OP_IMM) {
            // Immediate size in bytes
            int imm_size = insn->detail->x86.operands[i].size / 8;
            if (imm_size <= 0) continue;
            
            // Immediate is at the end of the instruction
            if (size >= (size_t)imm_size) {
                for (int j = 0; j < imm_size; j++) {
                    if (bytes[size - imm_size + j] == 0x00) {
                        return 1;
                    }
                }
            }
            break; // Only check first immediate
        }
    }
    return 0;
}

/**
 * Get the immediate value from instruction.
 * Returns 0 if no immediate found.
 */
static uint32_t get_immediate_value(cs_insn *insn) {
    for (int i = 0; i < insn->detail->x86.op_count; i++) {
        if (insn->detail->x86.operands[i].type == X86_OP_IMM) {
            return (uint32_t)insn->detail->x86.operands[i].imm;
        }
    }
    return 0;
}

/**
 * Count bytes in instruction that are 0x00.
 */
static int count_null_bytes(const uint8_t *bytes, size_t size) {
    int count = 0;
    for (size_t i = 0; i < size; i++) {
        if (bytes[i] == 0x00) {
            count++;
        }
    }
    return count;
}

/* ============================================================================
 * Strategy 1: VEX2 to VEX3 conversion for immediate field shifting
 * ============================================================================ */

/**
 * Check if we can handle VEX2 instruction with null byte in immediate.
 */
static int can_handle_vex2_to_vex3(cs_insn *insn) {
    (void)insn; // Parameter will be used below
    
    // Must be VEX prefixed
    if (!has_vex_prefix(insn)) {
        return 0;
    }
    
    // Must have immediate operand
    if (!has_immediate_operand(insn)) {
        return 0;
    }
    
    // Must have null bytes in immediate
    if (!has_null_bytes_in_immediate(insn)) {
        return 0;
    }
    
    // Original instruction must be VEX2 (C5 prefix)
    const uint8_t *bytes = insn->bytes;
    if (bytes[0] != 0xC5) {
        return 0;
    }
    
    // Check if we can convert to VEX3
    // VEX2 format: C5 [RvvvvLpp]
    // VEX3 format: C4 [RXBmmmmm] [WvvvvLpp]
    // We need to ensure we can map the bits correctly
    
    return 1;
}

/**
 * Get conservative size estimate for VEX2 to VEX3 conversion.
 */
static size_t get_size_vex2_to_vex3(cs_insn *insn) {
    (void)insn;
    
    // VEX2 to VEX3 conversion adds 1 byte for the extra prefix byte
    // Plus we might need to adjust the immediate value
    // Conservative estimate: original size + 5 bytes
    return insn->size + 5;
}

/**
 * Generate VEX2 to VEX3 converted instruction.
 */
static void generate_vex2_to_vex3(struct buffer *b, cs_insn *insn) {
    const uint8_t *orig_bytes = insn->bytes;
    size_t orig_size = insn->size;
    
    // VEX2 format: C5 [RvvvvLpp]
    // VEX3 format: C4 [RXBmmmmm] [WvvvvLpp]
    
    uint8_t vex2_byte = orig_bytes[1]; // RvvvvLpp
    
    // Extract fields from VEX2
    uint8_t R = (vex2_byte >> 7) & 0x01;  // R bit
    uint8_t vvvv = (vex2_byte >> 3) & 0x0F; // vvvv field
    uint8_t L = (vex2_byte >> 2) & 0x01;  // L bit
    uint8_t pp = vex2_byte & 0x03;        // pp field
    
    // For VEX3, we need to choose m-mmmmm map
    // Map 0x01 is commonly used as alternative
    uint8_t mmmmm = 0x01; // Alternative map
    
    // Construct VEX3 bytes
    // First byte: C4
    buffer_write_byte(b, 0xC4);
    
    // Second byte: RXBmmmmm
    // R bit inverted in VEX
    uint8_t vex3_byte1 = ((~R & 0x01) << 7) |  // R'
                         (0 << 6) |             // X (0 for 32-bit mode)
                         (0 << 5) |             // B (0 for 32-bit mode)
                         mmmmm;
    buffer_write_byte(b, vex3_byte1);
    
    // Third byte: WvvvvLpp
    uint8_t vex3_byte2 = (0 << 7) |            // W (0 for default)
                         (vvvv << 3) |         // vvvv field
                         (L << 2) |            // L bit
                         pp;                   // pp field
    buffer_write_byte(b, vex3_byte2);
    
    // Copy the rest of the instruction (opcode, ModR/M, SIB, displacement)
    // Skip the first 2 bytes (C5 + vex2_byte)
    for (size_t i = 2; i < orig_size; i++) {
        uint8_t byte = orig_bytes[i];
        
        // Check if this is part of the immediate
        int is_immediate_part = 0;
        if (has_immediate_operand(insn)) {
            // Find immediate size
            for (int j = 0; j < insn->detail->x86.op_count; j++) {
                if (insn->detail->x86.operands[j].type == X86_OP_IMM) {
                    int imm_size = insn->detail->x86.operands[j].size / 8;
                    if (imm_size > 0 && i >= orig_size - imm_size) {
                        is_immediate_part = 1;
                        break;
                    }
                }
            }
        }
        
        if (is_immediate_part) {
            // This is part of the immediate - we need to adjust it
            uint32_t orig_imm = get_immediate_value(insn);
            
            // Try to find an alternative immediate value without null bytes
            // For shift instructions, we can adjust the count
            // For simplicity, we'll try adding 1 (wrapping if needed)
            uint32_t new_imm = orig_imm + 1;
            
            // Check if the new immediate has no null bytes
            if (!is_bad_byte_free(new_imm)) {
                // Try subtracting instead
                new_imm = orig_imm - 1;
            }
            
            // Write the adjusted immediate
            // We need to write the appropriate number of bytes
            for (int j = 0; j < 4; j++) {
                uint8_t imm_byte = (new_imm >> (j * 8)) & 0xFF;
                if (imm_byte != 0x00) {
                    buffer_write_byte(b, imm_byte);
                } else {
                    // If we still have null bytes, use 0x01 as fallback
                    buffer_write_byte(b, 0x01);
                }
            }
            
            // Skip the rest of the immediate bytes
            break;
        } else {
            // Not part of immediate, copy as-is
            if (byte != 0x00) {
                buffer_write_byte(b, byte);
            } else {
                // Replace null bytes in non-immediate parts with safe value
                buffer_write_byte(b, 0x01);
            }
        }
    }
}

/* ============================================================================
 * Strategy 2: EVEX prefix manipulation for immediate field shifting
 * ============================================================================ */

/**
 * Check if we can handle EVEX instruction with null byte in immediate.
 */
static int can_handle_evex_remap(cs_insn *insn) {
    (void)insn; // Parameter will be used below
    
    // Must be EVEX prefixed
    if (!has_evex_prefix(insn)) {
        return 0;
    }
    
    // Must have immediate operand
    if (!has_immediate_operand(insn)) {
        return 0;
    }
    
    // Must have null bytes in immediate
    if (!has_null_bytes_in_immediate(insn)) {
        return 0;
    }
    
    return 1;
}

/**
 * Get conservative size estimate for EVEX remapping.
 */
static size_t get_size_evex_remap(cs_insn *insn) {
    (void)insn;
    
    // EVEX remapping might change prefix length
    // Conservative estimate: original size + 4 bytes
    return insn->size + 4;
}

/**
 * Generate EVEX remapped instruction.
 */
static void generate_evex_remap(struct buffer *b, cs_insn *insn) {
    const uint8_t *orig_bytes = insn->bytes;
    size_t orig_size = insn->size;
    
    if (orig_size < 4) {
        // Not enough bytes for EVEX prefix
        return;
    }
    
    // EVEX format: 62 [R X B R' mmmm] [W vvvv 1 pp] [z L' L b V' aaa]
    
    uint8_t evex_byte1 = orig_bytes[1]; // R X B R' mmmm
    uint8_t evex_byte2 = orig_bytes[2]; // W vvvv 1 pp
    uint8_t evex_byte3 = orig_bytes[3]; // z L' L b V' aaa
    
    // Extract fields
    uint8_t R = (evex_byte1 >> 7) & 0x01;
    uint8_t X = (evex_byte1 >> 6) & 0x01;
    uint8_t B = (evex_byte1 >> 5) & 0x01;
    uint8_t Rprime = (evex_byte1 >> 4) & 0x01;
    uint8_t mmmm = evex_byte1 & 0x0F;
    
    uint8_t W = (evex_byte2 >> 7) & 0x01;
    uint8_t vvvv = (evex_byte2 >> 3) & 0x0F;
    uint8_t pp = evex_byte2 & 0x03;
    
    uint8_t z = (evex_byte3 >> 7) & 0x01;
    uint8_t Lprime = (evex_byte3 >> 6) & 0x01;
    uint8_t L = (evex_byte3 >> 5) & 0x01;
    uint8_t broadcast = (evex_byte3 >> 4) & 0x01;
    uint8_t Vprime = (evex_byte3 >> 3) & 0x01;
    uint8_t aaa = evex_byte3 & 0x07;
    
    // Manipulate fields to change prefix encoding
    // Change R' bit to alter ModR/M byte position
    Rprime ^= 0x01; // Flip R' bit
    
    // Change aaa (embedded opmask) to alter prefix
    aaa = (aaa + 1) & 0x07;
    
    // Reconstruct EVEX bytes
    buffer_write_byte(b, 0x62); // EVEX prefix
    
    uint8_t new_evex_byte1 = (R << 7) | (X << 6) | (B << 5) | (Rprime << 4) | mmmm;
    buffer_write_byte(b, new_evex_byte1);
    
    uint8_t new_evex_byte2 = (W << 7) | (vvvv << 3) | (1 << 2) | pp;
    buffer_write_byte(b, new_evex_byte2);
    
    uint8_t new_evex_byte3 = (z << 7) | (Lprime << 6) | (L << 5) | (broadcast << 4) | (Vprime << 3) | aaa;
    buffer_write_byte(b, new_evex_byte3);
    
    // Copy the rest of the instruction
    for (size_t i = 4; i < orig_size; i++) {
        uint8_t byte = orig_bytes[i];
        
        // Check if this is part of the immediate
        int is_immediate_part = 0;
        if (has_immediate_operand(insn)) {
            for (int j = 0; j < insn->detail->x86.op_count; j++) {
                if (insn->detail->x86.operands[j].type == X86_OP_IMM) {
                    int imm_size = insn->detail->x86.operands[j].size / 8;
                    if (imm_size > 0 && i >= orig_size - imm_size) {
                        is_immediate_part = 1;
                        break;
                    }
                }
            }
        }
        
        if (is_immediate_part) {
            // Adjust immediate to avoid null bytes
            uint32_t orig_imm = get_immediate_value(insn);
            uint32_t new_imm = orig_imm;
            
            // Try different adjustments
            for (int adjust = 1; adjust <= 255; adjust++) {
                new_imm = orig_imm + adjust;
                if (is_bad_byte_free(new_imm)) {
                    break;
                }
                new_imm = orig_imm - adjust;
                if (is_bad_byte_free(new_imm)) {
                    break;
                }
            }
            
            // Write adjusted immediate
            for (int j = 0; j < 4; j++) {
                uint8_t imm_byte = (new_imm >> (j * 8)) & 0xFF;
                if (imm_byte != 0x00) {
                    buffer_write_byte(b, imm_byte);
                } else {
                    buffer_write_byte(b, 0x01);
                }
            }
            break;
        } else {
            // Copy non-immediate bytes
            if (byte != 0x00) {
                buffer_write_byte(b, byte);
            } else {
                buffer_write_byte(b, 0x01);
            }
        }
    }
}

/* ============================================================================
 * Strategy 3: General VEX/EVEX prefix remapping
 * ============================================================================ */

/**
 * Check if we can handle general VEX/EVEX remapping.
 */
static int can_handle_general_vex_evex_remap(cs_insn *insn) {
    (void)insn;
    
    // Must be VEX or EVEX prefixed
    if (!is_vex_evex_instruction(insn)) {
        return 0;
    }
    
    // Must have null bytes somewhere in the instruction
    if (!has_null_bytes_in_instruction(insn)) {
        return 0;
    }
    
    return 1;
}

/**
 * Get conservative size estimate for general VEX/EVEX remapping.
 */
static size_t get_size_general_vex_evex_remap(cs_insn *insn) {
    (void)insn;
    
    // General remapping might require more bytes
    // Conservative estimate: original size * 2
    return insn->size * 2;
}

/**
 * Generate general VEX/EVEX remapped instruction.
 */
static void generate_general_vex_evex_remap(struct buffer *b, cs_insn *insn) {
    const uint8_t *orig_bytes = insn->bytes;
    size_t orig_size = insn->size;
    
    // Count null bytes in original
    int null_count = count_null_bytes(orig_bytes, orig_size);
    
    if (null_count == 0) {
        // No null bytes to fix
        return;
    }
    
    // Determine prefix type
    if (has_vex_prefix(insn)) {
        // VEX instruction
        
        if (orig_bytes[0] == 0xC5) {
            // VEX2 - convert to VEX3
            generate_vex2_to_vex3(b, insn);
        } else {
            // VEX3 - manipulate prefix bytes
            
            // Write VEX3 prefix
            buffer_write_byte(b, 0xC4);
            
            // Manipulate second byte (RXBmmmmm)
            uint8_t byte1 = orig_bytes[1];
            // Flip some bits to change encoding
            byte1 ^= 0x20; // Flip X bit
            if (byte1 == 0x00) byte1 = 0x01;
            buffer_write_byte(b, byte1);
            
            // Manipulate third byte (WvvvvLpp)
            uint8_t byte2 = orig_bytes[2];
            byte2 ^= 0x04; // Flip L bit
            if (byte2 == 0x00) byte2 = 0x01;
            buffer_write_byte(b, byte2);
            
            // Copy rest with null byte replacement
            for (size_t i = 3; i < orig_size; i++) {
                uint8_t byte = orig_bytes[i];
                if (byte != 0x00) {
                    buffer_write_byte(b, byte);
                } else {
                    buffer_write_byte(b, 0x01);
                }
            }
        }
    } else if (has_evex_prefix(insn)) {
        // EVEX instruction
        generate_evex_remap(b, insn);
    }
}

/* ============================================================================
 * Strategy definitions
 * ============================================================================ */

// Strategy 1: VEX2 to VEX3 conversion
static int can_handle_strategy1(cs_insn *insn) {
    return can_handle_vex2_to_vex3(insn);
}

static size_t get_size_strategy1(cs_insn *insn) {
    return get_size_vex2_to_vex3(insn);
}

static void generate_strategy1(struct buffer *b, cs_insn *insn) {
    generate_vex2_to_vex3(b, insn);
}

static strategy_t vex2_to_vex3_strategy = {
    .name = "vex2_to_vex3_conversion",
    .can_handle = can_handle_strategy1,
    .get_size = get_size_strategy1,
    .generate = generate_strategy1,
    .priority = 90,
    .target_arch = BYVAL_ARCH_X86
};

// Strategy 2: EVEX remapping
static int can_handle_strategy2(cs_insn *insn) {
    return can_handle_evex_remap(insn);
}

static size_t get_size_strategy2(cs_insn *insn) {
    return get_size_evex_remap(insn);
}

static void generate_strategy2(struct buffer *b, cs_insn *insn) {
    generate_evex_remap(b, insn);
}

static strategy_t evex_remap_strategy = {
    .name = "evex_prefix_remapping",
    .can_handle = can_handle_strategy2,
    .get_size = get_size_strategy2,
    .generate = generate_strategy2,
    .priority = 90,
    .target_arch = BYVAL_ARCH_X86
};

// Strategy 3: General VEX/EVEX remapping
static int can_handle_strategy3(cs_insn *insn) {
    return can_handle_general_vex_evex_remap(insn);
}

static size_t get_size_strategy3(cs_insn *insn) {
    return get_size_general_vex_evex_remap(insn);
}

static void generate_strategy3(struct buffer *b, cs_insn *insn) {
    generate_general_vex_evex_remap(b, insn);
}

static strategy_t general_vex_evex_remap_strategy = {
    .name = "general_vex_evex_prefix_remapping",
    .can_handle = can_handle_strategy3,
    .get_size = get_size_strategy3,
    .generate = generate_strategy3,
    .priority = 85,
    .target_arch = BYVAL_ARCH_X86
};

/* ============================================================================
 * Registration function
 * ============================================================================ */

void register_vex_evex_prefix_remapping_for_avx_immediate_strategies(void) {
    register_strategy(&vex2_to_vex3_strategy);
    register_strategy(&evex_remap_strategy);
    register_strategy(&general_vex_evex_remap_strategy);
}