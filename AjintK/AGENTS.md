[['str, Any]):\n        super().__init__(\n            agent_id="example_agent', 'name="Example Agent', 'description="Demonstrates proper formatting', 'capabilities=["research', 'analysis'], ['T]` for parameters that can be None\n3. Use `Union[T1, T2]` for multiple possible types\n4. Import typing modules at the top of the file\n\nExample:\n```python\nfrom typing import Dict, List, Optional, Any\n\ndef run(self, task: str, context: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:\n    "', 'Execute agent task with proper type hints"', '\n    pass\n```\n\n### Naming Conventions\n1. Class names: PascalCase (e.g., `BaseAgent`, `ResearchAgent`)\n2. Function/method names: snake_case (e.g., `run_agent`, `get_tools`)\n3. Constants: UPPER_SNAKE_CASE (e.g., `MAX_RETRIES`, `DEFAULT_TIMEOUT`)\n4. Private methods: prefixed with underscore (e.g., `_setup_llm_provider`)\n5. Instance variables: snake_case (e.g., `agent_id`, `max_concurrent`)\n\n### Error Handling\n1. Use try/except blocks for operations that might fail\n2. Log errors with appropriate log levels\n3. Return structured error responses\n4. Fail gracefully with meaningful error messages\n\nExample:\n```python\ntry:\n    response_text = self.call_llm(prompt)\n    return {\n        "status": "success', 'findings": response_text\n    }\nexcept Exception as e:\n    logger.error(f"Agent failed: {str(e)}")\n    return {\n        "status": "error', 'error', 'str(e)\n    }\n```\n\n## Framework Architecture\n\n### Core Components\n1. **BaseAgent**: Abstract base class for all agents\n2. **AgentOrchestrator**: Coordinates agent execution\n3. **LLM Providers**: Multi-provider support (Anthropic, Google, Qwen, Mistral, DeepSeek)\n4. **Tool System**: Pre-built tool definitions\n5. **Memory System**: Persistent JSON-based storage\n\n### Agent Implementation\nAll agents must inherit from `BaseAgent` and implement:\n1. `__init__` method with proper configuration\n2. `run` method with task execution logic\n3. `get_tools` method (optional) for tool definitions\n\nExample template:\n```python\nclass CustomAgent(BaseAgent):\n    def __init__(self, config: Dict[str, Any]):\n        super().__init__(\n            agent_id="custom_agent', 'name="Custom Agent', 'description="Description of what this agent does', 'capabilities=["capability1', 'capability2'], ['Dict[str, Any]]:\n        return [\n            ToolDefinitions.file_read(),\n            ToolDefinitions.web_fetch()\n        ]\n\n    def run(self, task: str, context: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:\n        # Implementation here\n        pass\n```\n\n## Multi-Provider Support\n\n### Supported Providers\n1. Anthropic (Claude models)\n2. Google (Gemini models)\n3. Qwen (Qwen models)\n4. Mistral (Codestral models)\n5. DeepSeek (DeepSeek models)\n\n### Provider Configuration\nSet environment variables for each provider:\n```bash\nexport ANTHROPIC_API_KEY="your-key"\nexport GOOGLE_API_KEY="your-key"\nexport QWEN_API_KEY="your-key"\nexport MISTRAL_API_KEY="your-key"\nexport DEEPSEEK_API_KEY="your-key"\n```\n\n### Provider Selection\nUse configuration to select provider:\n```python\nconfig = {\n    "provider": "anthropic', 'model": "claude-3-5-sonnet-20241022', 'max_tokens": 4000\n}\n```\n\n## Orchestration Patterns\n\n### Single Agent\n```python\nagent = ResearchAgent(config)\nresult = agent.run("Research quantum computing applications")\n```\n\n### Parallel Swarm\n```python\norchestrator = AgentOrchestrator({"max_concurrent_agents": 3})\norchestrator.register_agent("researcher', 'ResearchAgent(anthropic_config))\norchestrator.register_agent("analyzer', 'AnalysisAgent(google_config))\nresult = orchestrator.run_swarm(\n    task="Analyze AI trends', 'agent_ids=["researcher', 'analyzer'], ['researcher', 'analyzer', 'synthesizer'], {'focus': 'AI market'}, ['Dict[str, Any]]:\n    return [\n        ToolDefinitions.file_read(),\n        ToolDefinitions.web_fetch(),\n        ToolDefinitions.file_write()\n    ]\n```\n\n## Communication Between Agents\nUse the AgentCommunication system:\n```python\nfrom framework import AgentCommunication\n\ncomm = AgentCommunication()\ncomm.send_message(\n    from_agent="agent_a', 'to_agent="agent_b', 'content="Need help with this task"\n)\nmessages = comm.receive_messages("agent_b")\n```\n\n## Configuration\nUse the config.yaml file for framework configuration:\n```yaml\napi:\n  provider: "anthropic"\n  model: "claude-3-5-sonnet-20241022"\n  max_tokens: 4000\n\norchestration:\n  max_concurrent_agents: 5\n  timeout: 300\n\nstorage:\n  memory_dir: ".agent_memory"\n  messages_dir: ".agent_messages"\n  artifacts_dir: "./artifacts']]